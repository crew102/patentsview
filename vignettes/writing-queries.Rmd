---
title: "Writing queries"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Writing queries}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo = FALSE, message = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Three ways to write the same query

Let's say you wanted to find all patents published in the last 10 years that have the word "dog" in their titles or abstracts and were assigned to either a US or Canadian organization. There are three different ways you can write your query: 

1. Use a raw character/JSON vector:

```{r}
'{"_and":[
        {"_gte":{"patent_date":"2007-03-01"}},
        {"_or":[
          {"_contains":{"patent_title":"dog"}},
          {"_text_all":{"patent_abstract":"dog"}}
        ]},
        {"_or":[
          {"_eq":{"assingee_country":"US"}},
          {"_eq":{"assingee_country":"CA"}}
        ]}
]}' -> query_v_1
```

2. Use a list (which will be converted to JSON by `search_pv`):

```{r}
list("_and" = 
     list(
        list("_gte" = list(patent_date = "2007-03-01")),
        list("_or" = 
               list(
                 list("_contains" = list(patent_title = "dog")),
                 list("_text_all" = list(patent_abstract = "dog"))
                 )
             ),
        list("_or" = 
               list(
                 list("_eq" = list(assingee_country = "US")),
                 list("_eq" = list(assingee_country = "CA"))
                 )
             )
    )
) -> query_v_2
```

3. Use the query domain specific language (DSL) provided in the `patentsview` package to create a query: 

```{r}
library(patentsview)
with_qfuns(
  and(
    gte(patent_date = "2007-03-01"),
    or(
      contains(patent_title = "dog"),
      text_all(patent_abstract = "dog")
    ),
    eq(assingee_country = c("US", "CA"))
  )
) -> query_v_3
```

## Why use the query DSL (method 3)?

We can see that all three versions of `query` shown above are equivalent:

```{r}
jsonlite::minify(query_v_1)
jsonlite::toJSON(query_v_2, auto_unbox = TRUE)
jsonlite::toJSON(query_v_3, auto_unbox = TRUE)
```

...So why would you ever want to use method 3 over methods 1 and 2? There are two main reasons:

1. **Query validation**

`search_pv` will check your query and throw a helpful error message if your provide your query as a list (methods 2 or 3). You will have to rely on the API's error message if you use method 1. `search_pv` will check your query for the following:

* The fields included in your query are OK query fields for the endpoint. For example, it would make sure that `assingee_country` can be used in the query argument if we sent the above queries to the patents endpoint.
* The comparison operator(s) you used can be used with the field's type. For example, it would confirm that the `contains` operator was used with fields whose type was "string" (`patent_title` above).
* You supplied the correct value type for the field (e.g., `patent_date` is a character, not an integer)

2. **Concise, easy to use syntax for complex queries**

Methods 1 and 3 shown above are both much shorter than method 2, making them easier to type out. Furthermore, it's a lot easier to get the JSON syntax correct when using method 3 (b/c you don't have to write any JSON at all) compared to method 1...The API is picky about the JSON syntax, so it's not trivial to get it right. For example, the API will throw an error if you use a box in your query when it is not absolutely necessary, even if your query is still valid JSON (e.g., `query = {"_gte":{"patent_date":["2007-03-01"]}}` will throw an error). 

Compared to method 1, method 3 will correctly[^1] "or" together values if you put them in a vector. For example, in the query shown above, a vector of two values was given for `assingee_country` (`c("US", "CA")`). This safely converted the single "equals" statement in the third element of the query (`eq(assingee_country = c("US", "CA"))`) to two separate equals statements that are "or'd" together. 

## Basics of the query DSL

* All of the functions that comprise the DSL are found in the `qry_funs` list (e.g., `qry_funs$eq()`). You can evaluate code in the context of this list using the function `with_qfuns()`. See  `?with_qfuns()` for an example that demonstrates how using this function saves you typing.

* There are two types of functions for the DSL:
  + **Comparison operators**. These functions are used to compare a field to a value. For example, using the "less than or equal to" function (`qry_funs$lte`), we can make sure that publication date of the patent is less than or equal to some date (e.g., `query = qry_funs$lte(patent_date = "2001-01-05")`). See the [comparison operators section](http://www.patentsview.org/api/query-language.html#field_list_format) online for a list of the 11 functions and what they do (note, the R equivalent of the function drops the leading "_"). 
  + **Array functions**. There are three of these (`and`, `or`, and `not`). You can use these functions to logically combine the calls to the comparison functions (e.g., require that the patent date is less than or equal to 2001-01-05 _and_ that the inventor's last name is "Ihaka": `query = with_qfuns(and(lte(patent_date = "2001-01-05"), eq(inventor_last_name = "Ihaka")))`).



[^1]: One may note that using "value arrays" is supposedly supported natively by the API. For example, the API documentation notes that the following GET request (which happens to work) uses value arrays: For example, the API documentation gives the following query as an example of their use: `'{"inventor_last_name":["Whitney","Hopper"]}'`. The problem with this is that the API is not consistent in its handling of value arrays like this. For many of the comparison operators, one cannot "or" together values like the above. Thus, the query DSL in `patentsview` never relies on value arrays when constructing the JSON.